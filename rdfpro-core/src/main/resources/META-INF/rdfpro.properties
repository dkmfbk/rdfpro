plugin.eu.fbk.rdfpro.RDFProcessors.create.read.r=\
\n@read|@r        Read quads from files, augmenting the input stream\
\n  [-b IRI]      use base IRI to resolve relative IRIs (default: empty base)\
\n  [-w]          rewrites BNodes on a per-file basis instead of preserving them\
\n  [-s]          force sequential (non multithread) parsing, even if it is possible\
\n  [-d]          dumps bad statements to a '.error' file named after the input file\
\n  [-l]          lenient mode: non-fatal parse errors are ignored and data emitted\
\n  [-q]          quiet mode: parse errors and warnings are not logged\
\n  FILE...       read from specified FILEs (also URLs supported)

plugin.eu.fbk.rdfpro.RDFProcessors.create.write.w=\
\n@write|@w       Writes quads to FILEs (round-robin) and emits them in output\
\n  [-c NUM]      the number of consecutive quads to write as a chunk to each FILE\
\n  FILE...       write to the specified FILEs

plugin.eu.fbk.rdfpro.RDFProcessors.create.tsv=\
\n@tsv            Writes a TSV file based on the result of a SPARQL SELECT query\
\n  [-q QUERY]    the query (default: SELECT ?s ?p ?o ?c { GRAPH ?c { ?s ?p ?o } })\
\n  [-p MAPPER]   evaluates query on partitions of input data given by MAPPER: either\
\n                a script, 'e' to map by entity (subject or object resource) or\
\n                string matching regex [spoc]+ to map by s, p, o, c components\
\n  FILE          write to the specified TSV FILE

plugin.eu.fbk.rdfpro.RDFProcessors.create.transform.t=\
\n@transform|@t   Discards/replaces quads based on matching and replace exp.\
\n  [EXP]         sequence of rules on quad components X (values: s, p, o, c):\
\n                  +X value list => quad dropped if X not belongs to list\
\n                  -X value list => quad dropped if X belongs to list\
\n                  =X value => component X replaced with value (after filters)\
\n                values are in Turtle and include following wildcard values: <*>\
\n                => any IRI; _:* => any BNode; * => any plain literal; *@* => any\
\n                lang literal; *^^* => any typed literal; *@xyz => literals lang\
\n                xyz; *^^<iri> => literals type <iri>; *^^ns:iri => literals type\
\n                ns:iri; *^^ns:* => literals any type with prefix ns; ns:* => any\
\n                IRI with prefix ns; <ns*> => any IRI in namespace ns

plugin.eu.fbk.rdfpro.RDFProcessors.create.unique.u=\
\n@unique|@u      Discards duplicates in the input stream\
\n  [-m]          merges quads with same <s,p,o> and different graphs in a unique\
\n                quad, put in a graph described with quads of all source graphs

plugin.eu.fbk.rdfpro.RDFProcessors.create.prefix.p=\
\n@prefix|@p      Adds missing prefix-to-namespace bindings\
\n  [-f FILE]     use prefixes from FILE instead of prefix.cc

plugin.eu.fbk.rdfpro.RDFProcessors.create.smush=\
\n@smush          Performs smushing, using a canonical IRI for each sameAs cluster\
\n  [-s]          skips emitting owl:sameAs quads for rewritten IRIs\
\n  [-c FILE]     loads precomputed owl:sameAs equivalence classes from FILE, in\
\n                the form of triples <canonical_IRI owl:sameAs alias_IRI>\
\n  [-b IRI]      use base IRI when loading FILE together with option -c\
\n  [-w]          rewrites BNodes when loading FILE together with option -c\
\n  IRI...        use ranked namespace IRIs to select canonical IRIs

plugin.eu.fbk.rdfpro.RDFProcessors.create.tbox=\
\n@tbox           Emits only quads belonging to RDFS or OWL TBox axioms.

plugin.eu.fbk.rdfpro.RDFProcessors.create.cbd=\
\n@cbd            Emits matched entities CBDs (https://www.w3.org/Submission/CBD/)\
\n  [-n IRI]      use namespace IRI to match entities\
\n  [-s]          emit symmetric CBD (ie, also quads with matched entity as object)\
\n  [-i]          include instances (ie, quads X rdf:type <matched entity>)\
\n  [-c]          include context statements (ie, quads in matched context entity)

plugin.eu.fbk.rdfpro.RDFProcessors.create.rdfs=\
\n@rdfs           Emits the RDFS closure of input quads\
\n  [-e RULES]    exclude RULES in comma-separated list (default: no exclusions)\
\n  [-d]          decompose OWL axioms to RDFS (e.g. equivalentClass -> subClass)\
\n  [-t]          drop uninformative <x rdf:type _:b> statements (default: keep)\
\n  [-C | -c IRI] emits closed TBox to default graph [-C] or graph IRI [-c]\
\n  [-b IRI][-w]  use base IRI [-b] and optional BNode rewriting [-w] to load TBox\
\n  [FILE...]     load TBox from FILE...

plugin.eu.fbk.rdfpro.RDFProcessors.create.stats=\
\n@stats          Emits VOID structural statistics for its input\
\n  [-n IRI]      use namespace IRI to mint IRIs for VOID dataset instances\
\n  [-p IRI]      create a dataset for graphs linked to a source via property IRI\
\n  [-c IRI]      look for graph-to-source quads in graph IRI\
\n  [-t NUM]      emits only VOID partitions with at least NUM entities or triples\
\n  [-o]          enable computation of void:classes and void:properties (costly)

plugin.eu.fbk.rdfpro.RDFProcessors.create.download=\
\n@download       Download quads from a SPARQL endpoint, augmenting the stream\
\n  [-q QUERY]    use specified SPARQL QUERY (use quoting!)\
\n  [-f FILE]     load SPARQL QUERY from FILE\
\n  [-w]          rewrites downloaded BNodes rather than preserving them\
\n  URL           use endpoint at URL

plugin.eu.fbk.rdfpro.RDFProcessors.create.upload=\
\n@upload         Uploads quads to a SPARQL endpoint and emits them in output\
\n  [-s SIZE]     use chunks of SIZE quads for each upload call (default: 1024)\
\n  URL           use endpoint at URL

plugin.eu.fbk.rdfpro.RDFProcessors.create.mapreduce=\
\n@mapreduce      Performs a map/reduce like computation\
\n  [-b PRED]     directly emits input quads matching bypass predicate PRED\
\n  [-r REDUCER]  apply REDUCER to quad partitions (default: identity reducer)\
\n  [-e PRED]     keeps only partitions with a quad matching predicate PRED\
\n  [-a PRED]     keeps only partitions whose quads all match predicate PRED\
\n  [-u]          deduplicate partition quads before reducing\
\n  MAPPER...     map input quads using MAPPERs: either a script, 'e' to map by\
\n                entity (subject or object resource) or string matching regex\
\n                [spoc]+ to map by hash of selected s, p, o, c components

plugin.eu.fbk.rdfpro.ProcessorRules.create.rules=\
\n@rules          Emit the closure of input quads using a set of rules\
\n  [-r RULESETS] use comma separated list of RULESETs (rdfs, owl2rl, custom file)\
\n  [-B BINDINGS] use comma separated list of var=value BINDING to customize rules\
\n  [-p] MODE     set partitioning MODE: none (default), entity, graph, rules\
\n  [-g] MODE     set graph inference MODE: none (default), global, separate, star\
\n  [-G] IRI      set global graph IRI for inference modes global and star\
\n  [-t]          drop uninformative <x rdf:type _:b> statements (default: keep)\
\n  [-u]          emit unique statements (may be faster than separate @unique)\
\n  [-C | -c IRI] emit TBox data closure unchanged [-C] or to graph IRI [-c]\
\n  [-b IRI][-w]  use base IRI [-b] and BNode rewriting [-w] to load TBox data\
\n  [FILE...]     load TBox data (e.g., TBox) from FILE...\

plugin.eu.fbk.rdfpro.RDFProcessors.create.kvread=\
\n@kvread         Reads quads from a key-value index for keys selected by mapper\
\n  [-m MAPPER]   specify the mapper to apply to the input stream to select the\
\n                keys to read from the index: (see @mapreduce, default: subject)\
\n  [-r NSLIST]   recursively read data of URIs matching one of the supplied\
\n                namespaces (list separated by spaces or commas)\
\n  FILE          the key-value file to read from

plugin.eu.fbk.rdfpro.RDFProcessors.create.kvwrite=\
\n@kvwrite        Writes to a key-value index, partitioning quads by a mapper\
\n  [-m MAPPER]   specify the mapper to derive the key an input quad is stored\
\n                under (see @mapreduce, default: subject)\
\n  FILE          the key-value file to write (replaced if existing)

plugin.eu.fbk.rdfpro.RDFProcessors.create.nop=\
\n@nop            No-operation processor that emits its input unchanged

plugin.eu.fbk.rdfpro.RDFProcessors.create.pseudoclass=\
\n@pseudoclass    For each statement <s, p, o, c> emits pseudo-class statements:\
\n                  <s, rdf:type, pc(p), c>, (pc(x1..xn) pseudo-class for x1..xn)\
\n                  <s, rdf:type, pc(p,o), c> (if o is IRI)\
\n                  <o, rdf:type, pc(p,inv), c> (if o IRI)\
\n                  <o, rdf:type, pc(p,s,inv), c> (if o IRI, s IRI)\
\n  [-n IRI]      use namespace IRI to generate pseudo-class IRIs\
\n  [-i NUM]      emits only pseudo-classes with at least NUM instances\
\n  [-c NUM]      emits at most NUM pseudo-classes with the most instances each\
\n  [-t]          emits also TBox (rdfs:subClassOf) statements for pseudo-classes

rdfpro.rules.rhodf=classpath:/eu/fbk/rdfpro/rules/rhodf.ttl
rdfpro.rules.rdfs=classpath:/eu/fbk/rdfpro/rules/rdfs.ttl
rdfpro.rules.horst=classpath:/eu/fbk/rdfpro/rules/horst.ttl
rdfpro.rules.owl2rl=classpath:/eu/fbk/rdfpro/rules/owl2rl.ttl

scripting.js.includes.rdfpro = classpath:/eu/fbk/rdfpro/util/scripting.js
scripting.groovy.includes.rdfpro = classpath:/eu/fbk/rdfpro/util/scripting.groovy
